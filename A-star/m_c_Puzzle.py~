from astar import AstarState, AstarNodeState

class m_c_Puzzle(AstarState):
	#MANHATTAN HEURISTIC
	def heuristic(self, node, start, end):
		ans = 0
		for i in xrange(9):
			if node.array[i]==0:
				continue
			num = node.array[i]
			row = i/3
			col = i%3
			expi = (num-1)/3
			expj = (num-1)%3
			ans += abs(expi - row) + abs(expj - col)
		return ans

	#MISPLACED TILES HEURISTIC
	# def heuristic(self, node, start, end):
	# 	ans = 0
	# 	for i in xrange(9):
	# 		if node.array[i]==0:
	# 			continue
	# 		num = node.array[i]
	# 		row = i/3
	# 		col = i%3
	# 		expi = (num-1)/3
	# 		expj = (num-1)%3
	# 		if ((row != expi) or (col != expj)):
	# 			ans+=1
	# 	return ans


class puzzleState(AstarNodeState):
	def __init__(self, array):
		self.array = array
		self.g = 0
		self.h = 0
		self.parent = None

	def getAllNextStates(self):
		returnList = []
		l = list(self.array)
		l1 = l
		l2 = l
		l2[0] = 3 - l1[0]
		l2[1] = 3 - l1[1]
		l2[2] = not(l1[2])
		pos = -1
		for i in range(len(self.array)):
			if self.array[i] == 0:
				pos = i
		if pos>=3:
			l = list(self.array)
			temp = l[pos]
			l[pos] = l[pos-3]
			l[pos-3] = temp
			p = puzzleState(tuple(l))
			returnList.append(p)
		if pos<6:
			l = list(self.array)
			temp = l[pos]
			l[pos] = l[pos+3]
			l[pos+3] = temp
			p = puzzleState(tuple(l))
			returnList.append(p)
		if pos%3!=2:
			l = list(self.array)
			temp = l[pos]
			l[pos] = l[pos+1]
			l[pos+1] = temp
			p = puzzleState(tuple(l))
			returnList.append(p)
		if pos%3!=0:
			l = list(self.array)
			temp = l[pos]
			l[pos] = l[pos-1]
			l[pos-1] = temp
			p = puzzleState(tuple(l))
			returnList.append(p)
		return returnList

	def move_cost(self, node):
		return 1

	def printState(self):
		for i in range(3):
			print self.array[i],
		print

	def equal(self, state):
		for i in range(3):
			if self.array[i] == state.array[i]:
				continue
			else:
				return False
		return True
	
	def validState(array):
		if array[0]<0 or array[1]<0 or array[0]>3 or array[1]>3:
			return False
		elif array[0]==0:
			return True
		elif array[0]>=array[1]:
			return True
		else:
			return False

def main():
	start = (3,3,True)
	end = (0,0,False)
	startState = puzzleState(start)
	endState = puzzleState(end)
	puzzle = eightPuzzle(startState)
	path = puzzle.search(startState, endState)
	# path = puzzle.bidirectional_search(startState, endState)
	for i in path:
		i.printState()
		print
	print "The number of steps needed : ", len(path)-1

main()
